\section{Mining with Variable Difficulty}\label{sec.variable}

We now adapt the construction of the previous sections to the variable
difficulty model.
%The key observation in our construction is that the verifier
%does not recalculate the target, but only uses the target of the genesis epoch,
%$T_0$. This allows the verifier to extract the chain with the most work. That
%is, we define the upchain operator as follows:
%
%\begin{definition}[Upchain]
%  Let $\chain$ be a chain and $\mu \in \mathbb{N}$.
%  Define the \emph{upchain} $\chain\upchain^\mu$ of $\chain$ to be the
%  subchain $\{B \in \chain: H(B) \leq 4^{-\mu} T_0\}$ where
%  $T_0$ is the minimum-difficulty target.
%\end{definition}
The chain compression construction and verifier are identical to that the
previous section, but with a modified upchain operator as follows.
Let $\chain$ be a chain and $\mu \in \mathbb{N}$.
Define the \emph{upchain} $\chain\upchain^\mu$ of $\chain$ to be the
subchain $\{B \in \chain: H(B) \leq 4^{-\mu} T_0\}$ where
$T_0$ is the minimum-difficulty target.

% \import{.}{./chapters/superlight/algorithms/alg.nipopow-variable-verifier.tex}

% TODO: Mention that Dissolve is an idempotent operation.

We conjecture that the above construction is secure and succinct in the
variable difficulty model as defined in \cite{backbone}. We sketch below the
arguments to support this conjecture, assuming that our Unsupressibility Lemma
and the $Q$-block Common-Prefix Lemma transfer to the variable difficulty model.

% TODO: Prove that we have historical validity and persistence -- \emph{security}
% here is ill-defined.

\begin{definition}[Superqueries]
A random oracle query is called $\mu$-successful if
its output does not fall above $2^{\mu - \kappa} T_0$.
\end{definition}

Let

\begin{align*}
X_r\upchain^\mu = \begin{cases}
  1\text{, if an honest party queried $H$ with a $\mu$-successful query during $r$}\\
  0\text{, otherwise}
\end{cases}\,.
\end{align*}

\begin{align*}
Y_r\upchain^\mu = \begin{cases}
  1&\text{, if an honest party queried $H$ with a $\mu$-successful query during $r$}
   \\
   &\text{  and $r$ was a uniquely successful and isolated round}
    \\
  0&\text{, otherwise}
\end{cases}\,.
\end{align*}

\begin{align*}
Z_{r k}\upchain^\mu = \begin{cases}
  1\text{, if the } k^\text{th} \text{ adversarial query during round $r$
           was $\mu$-successful}\\
  0\text{, otherwise}
\end{cases}\,.
\end{align*}

Let $Z_r = \sum_{k = 1}^t Z_{r k}$.

Let $S$ be a set of consecutive rounds. Then let
$X^S\upchain^\mu = \sum_{r \in S}X_r\upchain^\mu$,
$Y^S\upchain^\mu = \sum_{r \in S}Y_r\upchain^\mu$ and
$Z^S\upchain^\mu = \sum_{r \in S}Z_r\upchain^\mu$.

\begin{definition}[Ground level]
  Let $r$ be a round. The \emph{ground level} of $r$ is defined as
  $\mu^*_r = \lceil\lg(\frac{n_r}{\eta n_0})\rceil$. Let $S$ be a set of rounds.
  Then the \emph{ground level} of $S$ is defined as
  $\mu^*_S = \max_{r \in S}\mu^*_r$.
\end{definition}

\begin{definition}[Variable Superblock Typicality]
  An execution $\mathcal{E}$ is \emph{superblock-typical} if
  for all $\mu \in \mathbb{N}$ and
  for all sets $S$ of consecutive rounds such that $|S| \geq \lambda 2^\mu$,
  the following hold:

  \begin{itemize}
    \item $|X^S\upchain^\mu| < (1 + \epsilon) p n(S) 2^{-\mu}   $.
    \item If $\mu \geq \mu^*_S$, then $|Y^S\upchain^\mu| \geq (1 - \epsilon)  (1-\theta f)^{\Delta+1} p n(S) 2^{-\mu}  $.
    \item $|Z^S\upchain^\mu| < (1 + \epsilon)  p t(S) 2^{-\mu}   $.
  \end{itemize}
\end{definition}

\begin{theorem}[Variable Superblock Typicality]
  Consider an ITM system $(\mathcal{Z}, C)$ which runs in $L$ steps.
  The probability of the event ``$\mathcal{E}$ is \emph{not}
  superblock-typical'' is bounded by $e^{-\Omega(\kappa) + \lg{L}}$.
\end{theorem}
\begin{proof}[Sketch]
  Apply some Chernoff bounds... TODO
\end{proof}

\begin{lemma}[Pairing]\label{lem:pairing}
  Let $r$ be a $\Delta$-isolated uniquely successful round and $B$ be the block
  generated by the honest parties during $r$ extending chain $\chain$. Consider
  any other chain $\chain'$ and a block $B'$ such that
  $\diff(\chain) \leq \diff(\chain') < \diff(\chain B)$
  or
  $\diff(\chain) < \diff(\chain' B') \leq \diff(\chain B)$.
  Then $B'$ was computed by the adversary.
\end{lemma}
\begin{proof}
  Observe that $\diff(\chain') < \diff(\chain B)$
  and $\diff(\chain' B') > \diff(\chain)$.
  We will show that $B'$ could not have been honestly generated during any
  round $r$. We distinguish the cases $u - \Delta \leq r < u + \Delta$,
  $r \geq u + \Delta$, and $r < u - \Delta$.
  Since $u$ is a $\Delta$-isolated uniquely successful round, block $B'$ could
  not have been generated by an honest party during any round $r$ with
  $u - \Delta \leq r < u + \Delta$.
  During any round $r \geq u + \Delta$, all honest parties have received
  $\chain B$ and so would extend only chains with difficulty at least
  $\diff(\chain B)$, and so they would not extend $\chain'$ since
  $\diff(\chain') < \diff(\chain B)$.
  During any round $r < u - \Delta$, if an honest party had generated $B'$, then
  it would have been received by all other honest parties by round $u$.
  Since $\diff(\chain' B') > \diff(\chain)$, this contradicts that the honest
  party extended $\chain$ during $u$.
\end{proof}

\begin{definition}[$\Delta$-expansion]
  Let $S$ be a set of rounds. We define the $\Delta$-expansion of $S$ to be the set
  $\dexpand{S} = \{r' \in \mathbb{N}: \exists r \in S: |r - r'| \leq \Delta\}$.
\end{definition}

\begin{lemma}[Cost of Suppression]\label{lem:suppression}
  Consider a $\Delta$-isolated uniquely successful round $r$ during which block
  $B$ was produced by an honest party. If at a later round $r' > r + \Delta$
  some honest party has a chain that does not contain $B$, then there exists
  a set $S$ of consecutive rounds such that
  $r \in S$
  and $A(J) \geq Q(S)$, where $J$ is the set of adversarial queries made
  during $\dexpand{S}$.
\end{lemma}
\begin{proof}
  Let $\chain$ denote the chain that $B$ extends.
  Let $r' > r + \Delta$ be the first round during which an honest party has a
  chain $\chain'$ which does not contain $B$.
  It will hold that $\diff(\chain') \geq \diff(\chain B)$.
  Let
  $b = (\chain \cap \chain')[-1]$ and let $b^*$ be the most recent block
  preceding $b$ which was honestly generated during a $\Delta$-isolated uniquely
  successful round.
  Let $r^*$ denote the round during which $b^*$ was generated
  and $\chain^*$ be the chain that $b^*$ extends.
  Let $S = \{r^* + \Delta, \cdots, r' - \Delta\}$.
  Then $S$ contains $r$.
  Let $T$ be the set of $\Delta$-isolated uniquely successful rounds in
  $S$. For any $r_1, r_2 \in T$ with $r_1 < r_2$ producing $b_1$ and $b_2$ and
  extending $\chain_1$ and $\chain_2$ respectively, it will hold that
  $\diff(\chain_1 b_1) \leq \diff(\chain_2)$ and the difficulties do not
  overlap.
  Let $J$ be the set of adversarial queries made during $\dexpand{S}$.
  We claim that $A(J) \geq Q(S)$.
  Consider any $r''$ in $T$
  during which block $b''$ was honestly generated and let $b''$ extend chain $\chain''$.
  Since $r^*$ was a successful round and $r'' > r^* + \Delta$, therefore
  $\diff(\chain'') \geq \diff(\chain^* b^*)$.
  We will use Lemma~\ref{lem:pairing} to pair the difficulty of block $b''$
  against adversarially generated difficulty.
  We distinguish two cases.
  \paragraph{Case $b'' \not\in \chain':$} As $r'' + \Delta \leq r'$, therefore
  $\diff(\chain''b'') \leq \diff(\chain')$ and $b''$ can be paired against
  adversarial difficulty in $\chain'$.
  \paragraph{Case $b'' \in \chain':$}
  Since $r$ is $\Delta$-isolated uniquely successful, we must have
  $r'' \leq r - \Delta$ or $r'' \geq r + \Delta$.
  If $r'' \leq r - \Delta$ then $\diff(\chain'' b'') \leq \diff(\chain B)$,
  otherwise $B$ would not have been honestly generated.
  If, on the other hand, $r'' \geq r + \Delta$, then by the minimality of
  $r'$, again we obtain
  $\diff(\chain'' b'') \leq \diff(\chain B)$. Therefore we can pair $b''$ against
  adversarial difficulty in $\chain$. To see this, observe that, if $b'' \in
  \chain'\setminus\chain$, then it does not belong to $\chain$ and we are done;
  but if $b'' \not\in \chain'\setminus\chain$, then $b''$ cannot be in
  $\chain\{b^*{:}b\}$ by the definition of $b^*$.

  We conclude that

  \[
  A(J) =
  \sum_{r \in J} A(r) \geq \sum_{r \in T} Q(r) = \sum_{r \in S} Q(r)
  = Q(S)\,.
  \]
\end{proof}

\begin{lemma}[Unsuppressibility]
  In an $(\epsilon, \eta, \theta)$-typical execution, every set of consecutive
  rounds $U$ has a subset $S$ of $\Delta$-isolated uniquely successful rounds
  such that:
  \begin{itemize}
    \item $|S| \geq Q(U) - 3A(U) - 2\ell(1 + \epsilon)\tau\alpha(J)/\epsilon$
    \item at any round after $\dexpand{S}$, every honest party has a
          chain which contains all the blocks corresponding to $S$.
  \end{itemize}
  where $J$ is the set of adversarial queries in $\dexpand{U}$.
\end{lemma}
\begin{proof}[Sketch]
  Let $U' = \{\min U - \ell, \cdots, \max U + \ell\}$.
  Let $S$ contain all those $r \in U$ such that for any $S' \subseteq U'$
  it holds that $Q(S') > A(S')$. From typicality it follows that
  any $S'$ with elements outside of $U'$ cannot have $Q(S') > A(S')$,
  as $|S'| \geq \lambda$.
  Consider the minimum collection $\mathcal{T}$ of sets of consecutive rounds
  with the following properties:

  \begin{itemize}
    \item For all $T \in \mathcal{T}: Q(T) \leq A(\dexpand{T})$.
    \item $U \setminus S \subseteq \bigcup \mathcal{T}$.
  \end{itemize}

  Now, observe that due to the minimality of $\mathcal{T}$, no round $r$ in
  $U \setminus S$ is covered by more than $2$ different spans
  $T_1, T_2 \in \mathcal{T}$. For, if it were covered by different spans
  $T_1, T_2, T_3 \in \mathcal{T}$, then we could keep only these two spans among
  them that are the left-most and right-most.

  Call a round $r \in U \setminus S$:
  \begin{itemize}
    \item a \emph{sentinel} if it is covered only by one span in $\mathcal{T}$;
    \item a \emph{non-sentinel} otherwise.
%    \item a \emph{left-sentinel} if it is a sentinel and it has an immediately preceding
%        round in $U \setminus S$ which is covered by two spans in $\mathcal{T}$;
%    \item a \emph{right-sentinel} if it is a sentinel and it has an immediately subsequent
%        round in $U \setminus S$ is covered by two spans in $\mathcal{T}$;
%    \item a \emph{both-sentinel} if it is a left-sentinel and a right-sentinel;
%    \item a \emph{mid-sentinel} if it is a sentinel, but not a both-sentinel.
  \end{itemize}

  Let $\dexpand{\mathcal{T}} = \{\dexpand{T}: T \in \mathcal{T}\}$ and let us examine
  how many $\dexpand{T} \in \dexpand{\mathcal{T}}$ can cover a particular round $r$.
  Consider an arbitrary round $r \in U \setminus S$.

  If $r$ is a non-sentinel, then it is covered by two spans
  $T_1, T_2 \in \mathcal{T}$. Consider the
  largest round $r' < r$ with $r' \in U \setminus S$, and note that such a round
  must exist. Necessarily, $r'$ will be covered be either $T_1$ or $T_2$, or
  both, but by no other span: As $r - r' \geq \Delta$, any span $T'$ which
  covers rounds prior to $r'$ cannot extend to the right to cover $r$; that is,
  $\max{\dexpand{T'}} < r$. A symmetric argument can be made for any spans on the
  right side of $r$. Therefore, non-sentinel rounds can only be covered by up to
  two spans in $\dexpand{\mathcal{T}}$.

%  If $r$ is a sentinel that is not a right-sentinel, then it is covered by
%  a span $T \in \mathcal{T}$ and must
%  be preceded by a left-sentinel $r_L$ covered by only $T$
%  such that $r_L + \Delta \leq r$. As such, no span in $\mathcal{T}$ from the
%  right could be $\Delta$-extended to cover $r$, and only up to one span in
%  $\mathcal{T}$ from the left could be $\Delta$-extended to cover $r$.
%  A symmetric argument can be made for sentinels that are not left-sentinels.
%  Therefore, mid-sentinels can also only be covered by up to two spans in
%  $\dexpand{\mathcal{T}}$.

%  Lastly, if $r$ is a both-sentinel, then up to two spans (one from the left and
%  one from the right) can be $\Delta$-extended to cover it, so it can be covered
%  by up to three spans in $\dexpand{\mathcal{T}}$. However, for each both-sentinel,
%  the immediately preceding and the immediately subsequent round in
%  $U \setminus S$ is a non-sentinel; therefore the number of both-sentinels
%  cannot be more than half the non-sentinels.

  If $r$ is a sentinel, then up to two spans (one from the left and one from the
  right) can be $\Delta$-extended to cover it, so it can be covered by up to
  three spans in $\dexpand{\mathcal{T}}$.

  Let $q = Q(U)$ and $a = A(U)$.
  We need to show that
  $a - |S| \leq 3a + 2\ell (1 + \epsilon) \tau \alpha(J) / \epsilon$.

  \begin{align*}
  q - |S| = Q(U \setminus S) \leq \sum_{T \in \mathcal{T}} Q(T)
  \leq \sum_{T\in\mathcal{T}} A(\dexpand{T})\\
  \leq 3a + A(U' \setminus U) \leq 3a + 2\ell(1 + \epsilon) \tau \alpha(J) / \epsilon
  \end{align*}
\end{proof}

\begin{remark}[Bounds in the $q$-bounded setting]
  We note that the $|S| \gtrsim Q(U) - 3A(U)$ bound above requires a
  $\frac{1}{4}$-bounded adversary. This bound is due to the $\Delta$-bounded
  delay setting. However, the same proof can show that
  $|S| \gtrsim Q(U) - 2A(U)$ in the case of the variable difficulty model in
  the $q$-bounded synchronous setting. Therefore, a $\frac{1}{3}$-bounded
  adversary can be tolerated. The same bounds in the synchronous setting apply
  in all of the next theorems, establishing security against a $\frac{1}{3}$
  adversary in the variable difficulty $q$-bounded synchronous setting
  and against a $\frac{1}{4}$ adversary in the variable difficulty
  $\Delta$-bounded delay setting.
\end{remark}

\begin{theorem}[Variable Super Common Prefix]\label{thm:varscp}
  Consider an $(\epsilon, \eta, \theta)$-typical execution in a
  $(\gamma, s)$-respecting environment and suppose that for all $r$ it holds
  that $t_r < (\frac{1}{4} - \delta)n_r$ with
  $\frac{\delta}{2} > 2\epsilon + \theta f$.
  Consider a chain $\chain$ adopted by an honest party on round $r$ and let
  $\chain'$ be any other chain at round $r$. Let $b =
  (\chain\cap\chain')[-1]$ and $b^*$ be the most recent honest block in
  $\chain\cap\chain'$ produced at round $r_{b^*}$. Let $S = \{ r_{b^*}, \cdots,
  r \}$ and $\mu \geq \mu^*_S$. If $|C'\{b{:}\}\upchain^\mu| \geq 22\lambda
  f 2^{-\mu}$, then $|C\{b{:}\}\upchain^\mu| >
  |C'\{b{:}\}\upchain^\mu|$.
\end{theorem}
\begin{proof}[Sketch]
  Let $r^*$ be the round in which the most recent honestly generated block in
  $(\chain \cap \chain')[-1]$.
  Let $S = \{r^*, \cdots, r\}$. Let $W'$ denote the set of adversarial queries
  on $\chain' \setminus \chain$ at round $r' \geq r + \ell$ and
  $W$ the set of adversarial queries in $S \setminus W'$.

  We first observe that no query in $W'$ could have suppressed a
  $\mu$-superblock on $\chain\setminus\chain'$. As in the proof of
  Lemma~\ref{lem:suppression}, in such a case there would exist a set of consecutive
  rounds $|S^*| \geq \ell$ such that $Q(S^*) \leq A(J)$ where $J$ is the number
  of adversarial queries in $\dexpand{S^*}$. This contradicts typicality.

  TODO...
\end{proof}

\begin{conjecture}[Variable Multilevel Common Prefix]
  Consider an $(\epsilon, \eta, \theta)$-typical execution with $\tau \leq 2$.
  Let $\chain$ be an honestly adopted chain at round $r$ and let $\chain'$ be
  any other chain. Consider any $\mu' \geq \mu^*_r$ such that
  $|(\chain'\setminus\chain)\upchain^{\mu'}| > \frac{m}{2}$. Then there exists
  some $\mu > \mu'$ such that $|(\chain\setminus\chain')\upchain^\mu| >
  \frac{m}{2}$ and $2^\mu|(\chain\setminus\chain')\upchain^\mu| >
  2^{\mu'}|(\chain'\setminus\chain)\upchain^{\mu'}|$.
\end{conjecture}
\begin{proof}
\end{proof}

\begin{definition}[Admissible Chain]
  Consider a chain $\pi$ during a round $r$ and let $k'$
  be the \emph{minimum} parameter such that
  $\text{diff}(\pi[-k':]) \geq k \frac{n_r}{\eta n_0}$.
  Let $b = \pi[:-k'][-1]$ and consider the round $r_b$ during
  which $b$ was produced.
  We say that $\pi$ is \emph{admissible} at round $r$ if:
  \begin{itemize}
    \item $b$ belongs to the chain of an honest party during $r$ (persistence)
    \item $r_b \geq r - \frac{k}{\eta f}$ (liveness)
  \end{itemize}
\end{definition}

\begin{lemma}[Honest Chopping]\label{lem:honest-chop}
  Consider a NIPoPoW $\pi$ produced by an honest party during round $r$.
  Then $\pi$ is admissible at $r$.
\end{lemma}
\begin{proof}
  Let $k'$
  be the \emph{minimum} parameter such that
  $\text{diff}(\pi[-k':]) \geq k \frac{n_r}{\eta n_0}$.
  Clearly $b = \pi[-k':][-1]$ belongs to the chain of the honest party that
  produced $\pi$. It suffices to show that $r_b \geq r - \frac{k}{\eta f}$.
  Show that $m > k \geq k'$... TODO
\end{proof}

\begin{theorem}[Variable NIPoPoW Admissibility]\label{thm:admissibility}
  Consider an $(\epsilon, \eta, \theta)$-typical execution in a
  $(\gamma, s)$-respecting environment such that for all $r$ we have
  $t_r < (\frac{1}{4} - \delta)n_r$.
  Let $\pi$ and $\pi'$ be NIPoPoWs generated by an honest prover $B$
  and adversarial prover $\mathcal{A}$ respectively during round $r$. Let
  $\pi^*$ be the NIPoPoW selected by the honest verifier among $\pi$
  and $\pi'$. Suppose $\vec{n}$ is increasing during $[r]$ and
  that $V([r])$ is appropriately upper bound.
  Then $\pi^*$ is admissible at $r$.
\end{theorem}
\begin{proof}[Sketch]
  If $\pi$ is chosen, then both admissibility conditions hold by
  Lemma~\ref{lem:honest-chop}.
  Therefore, we will show that, if $\pi'$ is chosen, then it is admissible.
  Let $\mathcal{M} =
  \{\mu: \pi\upchain^\mu \cap \pi'\upchain^\mu \neq \emptyset\}$.
  \paragraph{Case 1: $\mathcal{M} = \emptyset$.}
  Consider $r^* = 0$ and let $S = \{0, \cdots, r\}$.
  If $\mathcal{M} = \emptyset$ then... chopping off will get us to genesis,
  which is honest and recent. TODO
  \paragraph{Case 2: $\mathcal{M} \neq \emptyset$.}
  Let
  $\mu = \min\mathcal{M}$. Let
  $b = (\pi\upchain^\mu \cap \pi'\upchain^\mu)[-1]$
  and let $b^*$ be the most recent honest block preceding $b$.
  Let $r^*$ be the round during which $b^*$ was generated
  and set $S = \{r^*, \cdots, r\}$.
  Let $\mu^* = \lceil\lg\frac{n_{r_\pi}}{n_0}\rceil$.
  \paragraph{Case 2a: $\mu > \mu^*$.}
  By the minimality of $\mu$, it will hold that
  $|\pi\{b{:}\}\upchain^\mu| \geq m$ (otherwise
  $b \in D[\mu - 1] \cap D'[\mu - 1] \neq \emptyset$).
  Furthermore, $\chain\{b{:}\}\upchain^\mu = \pi\{b{:}\}\upchain^\mu$.
  Apply Theorem~\ref{thm:varscp} to obtain
  $|\pi\{b{:}\upchain^\mu\}| > |\pi'\{b{:}\}\upchain^\mu|$.
  Therefore, in this case, $\pi$ will be chosen.
  \paragraph{Case 2b: $\mu \leq \mu^*$.}
  If the adversarial proof is chosen, then chopping off will get us to an
  honest fresh block because, from typicality,
  $\diff(\pi'\{b:\}) < A(\{r_{b^*}, \cdots, r\}) < ?$ must also be small. TODO
\end{proof}

\begin{remark}[Dropping difficulty]
  The above theorem establishes that a NIPoPoW verifier picks an admissible
  proof in cases of non-decreasing difficulty. If difficulty is allowed to
  decrease, then we can still establish a persistence guarantee in sacrifice of
  liveness. Let $b = (\pi\upchain^\mu\cap\pi'\upchain^\mu)[-1]$ where $\mu =
  \min{\mathcal{M}}$ as in the construction and let $r^*$ be the round
  during which the most recent honestly generated block preceding $b$ was
  generated.
  If $\mathcal{M} = \emptyset$ then set $r^* = 0$.
  Let $S = \{r^*, \cdots, r\}$
  and $\mu^* = \max_{r' \in S} \mu^*_{r'}$. First, observe
  that it is sufficient to only require difficulty to be non-decreasing during
  $S$, but can be allowed to decrease before $S$, and this ensures both liveness
  and persistence for the NIPoPoW verifier. In case difficulty has decreased
  \emph{during} $S$, then chopping off the minimum-length suffix with at least
  $2^{\mu^*}k$ difficulty from the selected proof $\pi^*$ ensures that the
  remaining chain has a tip adopted by all honest parties (establishing
  persistence), but may be stale (sacrificing liveness), as it could have been
  generated prior to round $r - \frac{k}{\eta f}$.
\end{remark}

\noindent
\textbf{Discovering the current difficulty.}
The last missing piece in creating a full variable-difficulty verifier is to
instruct the verifier to \emph{chop off} the correct amount of difficulty from
an admissible chain so that they obtain a stable and fresh block, achieving
persistence and liveness comparable to an honest full node. If they chop off too
little, they will arrive at a blockchain with non-stable tip, sacrificing
persistence. On the other hand, if they chop off too much, they will sacrifice
liveness, as their tip will be too old. Our goal is to ensure the NIPoPoW
verifier has comparable persistence and liveness to a full node. To chop off the
correct amount, the verifier needs to estimate the value of the ground level
$\mu^*$. The ground level can be estimated if the verifier can estimate the
current mining population. The verifier first finds an estimate $\approxn$ for
the population, and then sets $\mu^* = \lceil\lg\frac{n_0}{\eta\approxn}\rceil$.
The question is then how to estimate the population.

If we had a randomness beacon emitting every $\frac{m}{f}$ rounds, a NIPoPoW
verifier waking up from genesis and with only logarithmic state and
communication available could estimate the population after $2\frac{m}{f}$
rounds, since at least two beacon pulses will be emitted during them. The
verifier works as follows in this case. When the beacon emits the first pulse,
it begins collecting any block it sees on the network, regardless of which
chain it belongs to ---or indeed whether it belongs to a chain at all--- until
the second beacon pulse is detected. These blocks are collected into a set $S$.
The verifier then evalutes $\diff(S)$ as an estimate of the current difficulty
and estimates the current population as
$\approxn = \frac{\diff(S)f 2^\kappa}{n_0 m T_0}$. This certainly constitutes a
lower bound for the amount of difficulty queried during the epoch, but may
include stale blocks that were queried by the adversary and rebroadcast to
confuse the NIPoPoW verifier. To avoid this, since we have a beacon available,
we require every honest party to include the beacon randomness in every block
they generate. That way, the verifier only counts those blocks which include a
reference to the same randomness that it sees.

Based on the above protocol, we can now tackle the lingering question of how to
avoid the strong assumption that such a beacon entails. Note that the need for
the beacon stems from the requirement that the adversary should not be able to
predict its value and therefore is required to produce \emph{fresh} blocks to
convince the honest NIPoPoW verifier about the difficulty currently being
queried. The same unpredictability can be obtained if the NIPoPoW verifier
provides this value. In fact, we can implement this without any changes to the
standard protocol. When the NIPoPoW verifier wakes up during round $r$, it
produces a fresh random nonce $R$. It then creates a transaction $tx$ containing
$R$. We call this transaction a \emph{difficulty weather balloon} because it
will be diffused to the network to allow the verifier to make difficulty
measurements. Once the balloon has been diffused, from the
\emph{liveness} property of the ledger maintained by the full nodes, it will be
included in a block which will become stable within $u$ rounds where $u =
\frac{m}{16\tau f} + \frac{\gamma k}{\eta f (1 - \epsilon) (1 - \theta f)}$
denotes the liveness parameter.

The verifier counts all blocks that appear on the network from round $r + u$ to
round $r + u + \frac{m}{f}$. A block is collected into the set $S$ if it extends
a chain $\chain$ whose suffix
$\chain[-\lceil\frac{(1 + \epsilon)(m + u)}{\eta}\rceil{:}]$
contains a block containing $tx$. The requirement to look
only at the suffix ensures the NIPoPoW verifier does not need more than constant
communication resources and is not required to look at the full chain. The
following lemma ensures that the verifier will count all the difficulty
contributed by the honest parties.

\begin{lemma}\label{lem:balloon-honest}
Consider a typical execution and a transaction $tx$ diffused at round $r$. Then
all blocks honestly generated during rounds $\{r + \Delta + u, \cdots, r + u + \frac{m}{f}\}$
will each result in a chain $\chain$ whose suffix $\chain[-\lceil\frac{(1 +
\epsilon)(m + u)}{\eta}\rceil{:}]$ will contain $tx$.
\end{lemma}
\begin{proof}[Sketch]
  From the liveness of the underlying ledger, after $u$ rounds $tx$ will be
  included in the chain of every honest party. However, since $tx$ was generated
  at $r$, the chain cannot have grown more than
  $\frac{-(1 + \epsilon)(m + u)}{\eta}$ during $u + \frac{m}{f}$ rounds.
\end{proof}

The above ensures that
$\diff(S) \geq Q(\{r + u, \cdots, r + u + \frac{m}{f}\})$. This satisfies the
persistence requirement of the verifier. On the other hand, the freshness of
$tx$ ensures that the adversary could not have contributed too much work to
$S$. The following lemma makes this more precise:

\begin{lemma}\label{lem:balloon-bounds}
  Consider an $(\epsilon, \eta, \theta)$-typical execution. Let $tx$ be a transaction diffused during $r$
  and let $S$ be the set of blocks observed by an honest
  party during rounds $r + u, \cdots, r + u + \frac{m}{f}$ each of which creates a chain
  $\chain$ in which $tx$ is included in $\chain[-\lceil\frac{(1 + \epsilon)(m +
  u)}{\eta}\rceil{:}]$. Let $U = \{r, \cdots, r + u + \frac{m}{f}\}$.

  Then we have:

  \[
  Q(\{r + u - \Delta, \cdots, r + u + \frac{m}{f} + \Delta\})
  \leq \diff(S) \leq
  Q(U) + A(U)
  \]
\end{lemma}
\begin{proof}[Sketch]
  The first inequality follows from Lemma~\ref{balloon-honest}. For the second,
  observe that the adversary cannot use any queries made prior to $r$.
\end{proof}

\noindent\textbf{Removing balloon interactivity.}
The above protocol introduces some interactivity in the sense that the verifier
must produce the nonce in the balloon. However, such interactivity is
unnecessary as long as the verifier remains online for the duration of the
difficulty sampling. We can modify our protocol to be non-interactive as
follows. Initially, the verifier comes online at round $r$ and expects to be
provided with NIPoPoWs supporting an admissible chain. These NIPoPoWs must be
generated and diffused within round $r$. Any interested parties (including
honest and adversarial parties) generate such NIPoPoWs and diffuse them on the
network. At round $r + 1$, any honest parties who have diffused NIPoPoWs look
for competing proofs that have been provided by other honest parties or the
adversary. They collect all such proofs into a set $\mathcal{\Pi}$, which they
order and encode. They subsequently calculate the hash $h$ of the result. This
hash commits to all NIPoPoWs and can also be calculated by the NIPoPoW verifier.
The honest parties then diffuse a balloon transaction containing $h$ as a nonce.
The NIPoPoW verifier calculates the same nonce from the NIPoPoWs it has received
and observes the difficulty collection on the network as before. As soon as one
epoch completes, the NIPoPoW verifier can use the difficulty estimate as before.

\begin{theorem}[Security]
   Consider an $(\epsilon, \eta, \theta)$-typical execution in the variable
   difficulty $\Delta$-bounded delay setting so that for every $i$
   we have $t_i < (\frac{1}{4} - \delta)n_i$.
   Then the NIPoPoW prover of Algorithm~\ref{alg.nipopow-variable-verifier},
   coupled with the verifier which follows the balloon technique, is
   a secure PoPoW protocol.
\end{theorem}
\begin{proof}[Sketch]
  The theorem follows directly from Theorem~\ref{thm:admissibility} and
  Lemma~\ref{lem:balloon-bounds}.
\end{proof}
% \begin{proof}
% Assume $\Pi$ is a valid proof which corresponds to a valid chain $\chain$
% and $\Pi'$ is an adversarial proof.
% We need to show that if the adversary is not aware of a heavier valid chain
% $\chain'$, the verifier will accept $\Pi$.
%
% Note first that $b$ is always well defined as every valid proof
% contains the genesis block.
% When $\Pi$ has at least $m$ blocks of level $\mu_c$ after $b$, then
% Lemma~\ref{lemma:qblockcommonprefix} (invoked with the blocks of level
% $\mu_c$ as $Q$-blocks) ensures that $\Pi$ is accepted.
% So let us assume this is not the case and that both $\Pi$ and $\Pi'$ have
% fewer than $m$ blocks of level $\mu_c$ after $b$.
% This can only happen if $b$ is contained in the last part of $\Pi$ or
% $\Pi'$.
% As $m$ is at least as much as the number of blocks in an epoch, this last
% part (which is of size at least $2m$) contains a whole epoch before block $b$.
% Since the target of an epoch cannot be more than 4 times the target of
% the previous epoch, it follows that $\Pi$ and $\Pi'$ contain every block
% after $b$. Consequently, the verifier determines the heavier chain and
% always (correctly) accepts the corresponding proof.
% \end{proof}

\begin{theorem}[Succinctness]
  If $m \in O(\log|\chain|)$ and computational power is non-decreasing, then
  the superblock NIPoPoW construction is succinct.
\end{theorem}
\begin{proof}[Sketch]
The blocks of any level are
sufficiently concentrated in the second half of the chain (modulo the blocks
that were suppressed by the adversary, which are bounded in number due to the
Unsuppressibility Lemma). Thus, after $O(\log|C|)$ levels of the proof, the
chain will be exhausted for a total length in $O(m\log|C|)$.
\end{proof}

We remark that the number of blocks that must be inspected in any balloon
sampling is constant, and therefore the inclusion of such samples does not
change the succinctness of the verifier.
